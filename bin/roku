#!/bin/sh
# shellcheck disable=SC2002
set -aeu
ROKU_HISTORY_DIR="${XDG_CACHE_HOME:-${HOME}/.cache}/roku"
ROKU_HISTORY_FILE="${ROKU_HISTORY_DIR}/history"
ROKU_LOG_FILE="${ROKU_HISTORY_DIR}/log"
ROKU_CONFIG_DIR="${XDG_CONFIG_HOME:-${HOME}/.config}/roku"
ROKU_CONFIG_FILE="${ROKU_CONFIG_DIR}/config.sh"
ROKU_MEDIA_LIST="${ROKU_CONFIG_DIR}/watch.list"
ROKU_MEDIA_WATCHED="${ROKU_CONFIG_DIR}/watched.list"
ROKU_MEDIA_QUERY="${ROKU_HISTORY_DIR}/query.list"
ROKU_SEARCH_FAR_FROM_HOME="${ROKU_SEARCH_FAR_FROM_HOME:-3}"
SEARCH_URL='https://lite.duckduckgo.com/lite/'
OUTPUT="${ROKU_HISTORY_DIR}/search.html"
OUTPUT_TITLE="${ROKU_HISTORY_DIR}/title.html"
SEARCH_LIST=search.list
BIN_CURL='curl'
BIN_EXPR='expr'
BIN_FZF='fzf'
BIN_JQ='jq'
LL_DEBUG=1
LL_INFO=2
LL_WARN=3
LL_ERROR=4
LL_NONE=5
LOG_LEVEL="${LOG_LEVEL:-${LL_INFO}}"
log() {
	level="${1}"
	shift
	if [ "${level}" = DEBUG ]
	then
		level_number="${LL_DEBUG}"
	elif [ "${level}" = INFO ]
	then
		level_number="${LL_INFO}"
	elif [ "${level}" = WARN ]
	then
		level_number="${LL_WARN}"
	elif [ "${level}" = ERROR ]
	then
		level_number="${LL_ERROR}"
	else
		level="${LL_NONE}"
	fi
	if [ "${level_number}" -lt "${LOG_LEVEL}" ]
	then
		return
	fi
	message="$(printf '%s' "${*}" | sed 's@[\t]@\\t@; s@^@\t@')"
	date="$(date '+%Y-%m-%d %H:%M:%S')"
	printf '%s\t%s%s\n' "${date}" "level=${level}" "${message}" >>"${ROKU_LOG_FILE}"
}

http_get() {
	url="${1}"
	log DEBUG "Fetching URL: ${url}"
	"${BIN_CURL}" \
		-L \
		"${url}" \
		--silent \
		--show-error \
		-H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0' \
		-H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8' \
		-H 'Accept-Language: en-US,en;q=0.5' \
		-H 'Connection: keep-alive' \
		-H 'Upgrade-Insecure-Requests: 1' \
		-H 'Sec-Fetch-Dest: document' \
		-H 'Sec-Fetch-Mode: navigate' \
		-H 'Sec-Fetch-Site: same-origin' \
		-H 'Sec-Fetch-User: ?1' \
	;
	log DEBUG "Fetched URL: ${url}"
}
http_search() {
	data="${1}"
	log DEBUG "Searching term: ${data}"
	data="$(encode "${data}")"
	data="q=${data}&kl=&df="
	"${BIN_CURL}" \
		"${SEARCH_URL}" \
		-X POST \
		--silent \
		--show-error \
		-H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0' \
		-H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8' \
		-H 'Accept-Language: en-US,en;q=0.5' \
		-H 'Referer: https://lite.duckduckgo.com/' \
		-H 'Content-Type: application/x-www-form-urlencoded' \
		-H 'Origin: https://lite.duckduckgo.com' \
		-H 'Connection: keep-alive' \
		-H 'Upgrade-Insecure-Requests: 1' \
		-H 'Sec-Fetch-Dest: document' \
		-H 'Sec-Fetch-Mode: navigate' \
		-H 'Sec-Fetch-Site: same-origin' \
		-H 'Sec-Fetch-User: ?1' \
		--data-raw "${data}" \
	;
	log DEBUG "Searched term: ${data}"
}
post() {
	url="${1}"
	url="http://${ROKU_HOST}/${url}"
	log DEBUG "POSTing URL: ${url}"
	"${BIN_CURL}" \
		-d '' \
		--silent \
		--show-error \
		"${url}" \
	;
	log DEBUG "POSTed URL: ${url}"
}
type_text() {
	tmp="${*}"
	while [ -n "${tmp}" ]; do
		tail="${tmp#?}"
		first="${tmp%"${tail}"}"
		key="Lit_$(encode "${first}")"
		press "${key}"
		sleep .1s
		tmp="${tail}"
	done
}
search() {
	log INFO "Searching Roku for ${*}"
	press home
	sleep .5s
	for tmp in $(seq 1 ${ROKU_SEARCH_FAR_FROM_HOME})
	do
		press down
	done
	press right
	type_text "${@}"
	for tmp in $(seq 1 6)
	do
		press right
	done
	log INFO "Searched Roku for ${*}"
}
press() {
	for key in "${@}"
	do
		echo "${key}"
		log DEBUG "Pressing key: ${key}"
		url="keypress/${key}"
		post "${url}"
		log DEBUG "Pressed key: ${key}"
		sleep .5s
		if [ "${key}" = home ]
		then
			sleep 1s
		fi
	done
}
encode() {
	log DEBUG "Encoding text: ${*}"
	printf %s "${*}" \
	| "${BIN_JQ}" -sRr @uri \
	;
	log DEBUG "Encoded text: ${*}"
}
deeplink() {
	IFS='	'
	# shellcheck disable=SC2068
	set -- ${@}
	_type="${1}"
	if [ "${_type}" = tv ]
	then
		_type='tv-show'
	fi
	link="${2}"
	if "${BIN_EXPR}" "${link}" : '^https://www.netflix.com/title/' >/dev/null
	then
		link="${link##*/}"
		url="launch/12?contentId=${link}"
		url="${url}&MediaType=${_type}"
	elif "${BIN_EXPR}" "${link}" : '^https://www.amazon.com/' >/dev/null
	then
		link="${link##*/}"
		url="launch/13?contentId=${link}"
		url="${url}&MediaType=${_type}"
	else
		IFS=' '
		# shellcheck disable=SC2068
		set -- ${@}
		log INFO "Searching title: ${3}"
		search "${@}"
		log INFO "Searched title: ${3}"
		return 1
	fi
	log INFO "Launching title: ${3}"
	post "${url}"
	log INFO "Launched title: ${3}"
}
choose() {
	[ -d "${ROKU_HISTORY_DIR}" ] || mkdir "${ROKU_HISTORY_DIR}"
	rm "${ROKU_MEDIA_QUERY}" 2>/dev/null || true
	"${BIN_FZF}" \
		--bind="ctrl-w:execute(echo {}>>\"${ROKU_MEDIA_WATCHED}\")+execute(url=\$(echo {2} | sed 's@/@\\\/@g'); sed -i \"/\$url/d\" \"${ROKU_MEDIA_LIST}\")+reload(cat \"${ROKU_MEDIA_LIST}\")" \
		--bind="ctrl-x:execute(url=\$(echo {2} | sed 's@/@\\\/@g'); sed -i \"/\$url/d\" \"${ROKU_MEDIA_LIST}\")+reload(cat \"${ROKU_MEDIA_LIST}\")" \
		--bind="ctrl-a:print-query" \
		--print-query \
		--with-nth=1,3,4,5 \
		--delimiter='\t' \
		--preview='echo "Title:" {3}; echo "Year:" {4}; echo "Genre:" {5}; echo; echo {6};' \
		--preview-window='wrap' \
		--history="${ROKU_HISTORY_FILE}" \
	;
}
initialize_configuration() {
	log DEBUG Initializing configuration...
	[ -d "${ROKU_CONFIG_DIR}" ] || mkdir "${ROKU_CONFIG_DIR}"
	if ! [ -e "${ROKU_CONFIG_FILE}" ]
	then
		{
			echo "ROKU_HOST=192.168.0.7:8060"
			echo "ROKU_PROVIDERS='Netflix%2C+Prime+Video'"
			echo "ROKU_MEDIA_LIST=\"${ROKU_MEDIA_LIST}\""
		}>>"${ROKU_CONFIG_FILE}"
	fi
	if ! [ -e "${ROKU_MEDIA_LIST}" ]
	then
		{
			printf "tv	https://www.netflix.com/title/80057281	Stranger Things	2016	Horror	Strange things are afoot in Hawkins, Indiana, where a young boy's sudden disappearance unearths a young girl with otherworldly powers."
		}>>"${ROKU_MEDIA_LIST}"
	fi
	# shellcheck disable=SC1090
	. "${ROKU_CONFIG_FILE}"
	log DEBUG Initialized configuration.
}
list() {
	set +e
	line="$(choose < "${ROKU_MEDIA_LIST}" | tail -n1)"
	code="${?}"
	set -e
	if [ "${code}" -eq 0 ]
	then
		# match
		if [ -n "${line}" ]
		then
			if printf '%s' "${line}" | grep -q '	'
			then
				deeplink "${line}"
				return "${?}"
			else
				roku_list_add "${line}"
			fi
		fi
	elif [ "${code}" -eq 1 ]
	then
		# no match
		if [ -n "${line}" ]
		then
			roku_list_add "${line}"
		fi
	elif [ "${code}" -eq 2 ]
	then
		# error
		log ERROR "Errored title selection"
	elif [ "${code}" -eq 130 ]
	then
		# interupt
		log DEBUG "Cancelled title selection"
	else
		# unexpected
		log DEBUG "Unexpected problem with title selection"
	fi
}
main() {
	log DEBUG Starting program...
	initialize_configuration
	invoked_as="${1}"
	shift
	if [ "${invoked_as}" = 'roku-list-add' ]
	then
		roku_list_add "${@}"
		return "${?}"
	elif "${BIN_EXPR}" "${invoked_as}" ':' '.*-press-.*' >/dev/null 2>&1
	then
		key="${invoked_as##*-press-}"
		key="$(
			echo "${key}" \
			| tr '-' ' ' \
			| awk '{for(j=1;j<=NF;j++){ $j=toupper(substr($j,1,1)) substr($j,2) }}1' \
			| tr -d ' ' \
		)"
		press "${key}"
		return "${?}"
	elif [ "${#}" -eq 0 ]
	then
		list
	else
		search "${@}"
	fi
}
netflix_parse_year() {
	input="${1}"
	grep '<span class="title-info-metadata-item item-year" data-uia="item-year">' \
	<"${input}" \
	| sed 's@.*data-uia="item-year">@@; s@<.*@@' \
	;
}
netflix_search() {
	query="${1}"
	log INFO "Searching Netflix for '${query}'"
	http_search "site:www.netflix.com ${query}" >"${OUTPUT}"
	grep "href=\"https://www\.netflix.com/\(ph-en/\)\?[Tt]itle" "${OUTPUT}" \
	| sed 's@.*href="@@; s@".*@@;' \
	| uniq \
	| sort \
	| while read -r url
	do
		http_get "${url}" >"${OUTPUT_TITLE}"
		# shellcheck disable=2094
		grep '<script type="application/ld+json">' < "${OUTPUT_TITLE}" \
		| sed 's@^.*<script type="application/ld+json">@@; s@<.*@@' \
		| jq '.["@type"], .url, .name, "'"$(netflix_parse_year "${OUTPUT_TITLE}")"'", .genre, .description' \
		| sed 's@^"@@; s@"$@@; s@\\"@"@g' \
		| tr '\n' '\t' \
		| sed 's@\s*$@@' \
		| sed 's@^TVSeries@tv@; s@^Movie@movie@' \
		>>"${SEARCH_LIST}" \
		;
		printf '\n' >> "${SEARCH_LIST}"
	done \
	;
	log INFO "Searched Netflix for '${query}'"
}
prime_search() {
	query="${1}"
	log INFO "Searching Prime for '${query}'"
	http_search "site:amazon.com ${query}" >"${OUTPUT}"
	grep "href=\"https://www.amazon.com/.*Prime Video" "${OUTPUT}" \
	| sed 's@.*href="@@; s@".*@@;' \
	| uniq \
	| sort \
	| while read -r url
	do
		http_get "${url}" >"${OUTPUT_TITLE}.gz"
		gzip -d >"${OUTPUT_TITLE}" <"${OUTPUT_TITLE}.gz" \
		|| mv "${OUTPUT_TITLE}.gz" "${OUTPUT_TITLE}"
		grep '<script type="text/template">' < "${OUTPUT_TITLE}" \
		| sed 's@^.*<script type="text/template">@@; s@<.*@@' \
		| jq '.props .state .detail .headerDetail[] | .titleType, "'"${url}"'", .title, .releaseYear, ([.genres[].text]|join("; ")), .synopsis' \
		2>/dev/null \
		| sed 's@^"@@; s@"$@@; s@\\"@"@g' \
		| tr '\n' '\t' \
		| sed 's@\s*$@@' \
		| sed 's@^TVSeries@tv@; s@^Movie@movie@; s@^season@tv@' \
		>>"${SEARCH_LIST}" \
		;
		printf '\n' >> "${SEARCH_LIST}"
	done \
	;
	log INFO "Searched Prime for '${query}'"
}
roku_list_add() {
	log INFO Adding a new title...
	if [ -n "${1:-}" ]
	then
		line="${1}"
		shift
	else
		echo "ADD TO LIST: "
		read -r line
	fi
	! [ -e "${SEARCH_LIST}" ] || rm "${SEARCH_LIST}"
	netflix_search "${line}"
	prime_search "${line}"
	if [ -e "${SEARCH_LIST}" ]
	then
		log DEBUG Selecting a new title...
		line="$(fzf \
			--delimiter='\t' \
			--with-nth=1,3,4,5 \
			--multi \
			--delimiter='\t' \
			--preview='echo "Title:" {3}; echo "Year:" {4}; echo "Genre:" {5}; echo; echo {6}; echo; echo {2};' \
			--preview-window='wrap' \
			<"${SEARCH_LIST}" \
		)"
		if [ -n "${line}" ]
		then
			printf '%s\n' "${line}" >>"${HOME}/.config/roku/watch.list"
			log DEBUG Selected a new title.
		else
			log DEBUG Canceled a new title.
		fi
		rm "${SEARCH_LIST}" 2>/dev/null || true
	fi
	log INFO Added a new title...
}
on_exit() {
	log INFO Exiting...
	code="${?}"
	log DEBUG Cleaning up temporary files...
	rm "${ROKU_MEDIA_QUERY}" 2>/dev/null || true
	rm "${SEARCH_LIST}" 2>/dev/null || true
	log DEBUG Cleaned up temporary files.
	log INFO Exited.
	log INFO
	exit "${code}"
}

trap on_exit INT QUIT TERM EXIT
invoked_as="$(basename "${0}")"
main "${invoked_as}" "${@}"
